var EventEmitter = require('events').EventEmitter;
var MysqlAdapter = require('./MysqlAdapter');
var _ = require('underscore');

// A pool of mysql connnections
var MysqlConnectionPool = function MysqlConnectionPool(){ this.initialize.apply(this,arguments); return this; };
MysqlConnectionPool.prototype.initialize = function(configurations){
    this.setEventBindings();
    this.pool = _.map(configurations, function(config){
        return new MysqlAdapter({
            host     : config.host,
            user     : config.user,
            password : config.password,
            database : config.database
        });
    });
};
MysqlConnectionPool.prototype.setEventBindings = function(){
    _.extend(this, new EventEmitter());
    // On start, rotate the index for next connection
    this.on("start:query", function(connection, query){
        console.log("[start:query] ["+connection.config.host+"] ", query);
        this.nextIndex++;
    });
    // On completion, execute data-wrapped callback
    this.on("finish:query", function(connection, query, callback){
        console.log("[finish:query] ["+connection.config.host+"] ", query);
        callback();
    });
    // On network error, retry with another host
    this.on("error:query", function(connection, query, callback){
        console.log("[error:query] ["+connection.config.host+"] ", query);
        connection.close();
        this.query(query, callback);
    });
};
// Add a connection to the pool
MysqlConnectionPool.prototype.add = function(config){
    if (!this.pool) { this.pool = []; }
    this.pool.push(
        new MysqlAdapter({
            host     : config.host,
            user     : config.user,
            password : config.password,
            database : config.database
        })
    );
};
// Open all connections in the pool
MysqlConnectionPool.prototype.open = function(){
    this.nextIndex = 0;
    return _.map(this.pool, function(connection){
        if (connection.open()){
            return [connection.config.host, 'Opened'];
        } else if (connection.isOpen) {
            return [connection.config.host, 'Already Opened'];
        } else {
            return [connection.config.host, "Could Not Be Opened"];
        }
    });
};
// Close all connections in the pool
MysqlConnectionPool.prototype.close = function(){
    return _.map(this.pool, function(connection){
        return [connection.config.host, connection.close() ? 'Closed' : "Already Closed"];
    });
};
// Make a query to some connection in the pool
MysqlConnectionPool.prototype.query = function(query, callback){
    var self = this;
    var connection = this.nextConnection();
    if (!connection) { return false; }
    this.emit("start:query", connection, query);
    connection.query(query, function(err, rows, fields){
        if (err && err.fatal) {
            self.emit("error:query", connection, query, callback);
        } else {
            self.emit("finish:query", connection, query, function(){
                callback(err, rows);
            });
        }
    });
};
// Return all open connections in pool
MysqlConnectionPool.prototype.openConnections = function(){
    return _.filter(this.pool, function(connection){
        return connection.isOpen;
    });
};
// Return next available connection in pool (round-robin)
MysqlConnectionPool.prototype.nextConnection = function(){
    var open = this.openConnections();
    if (open.length === 0) { throw "Error: No available connections."; }
    if (open.length-1 <= this.nextIndex) { this.nextIndex = 0; } // reached pool boundary
    return this.pool[this.nextIndex];
};

module.exports = MysqlConnectionPool;